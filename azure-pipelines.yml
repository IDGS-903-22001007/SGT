# =====================================================
# üì¶ Pipeline CI/CD para App Flask (SGT)
# Flujo: CI (Build/Test) -> CD (Deploy a Azure WebApp)
# Objetivo: Desplegar login.html servido por Flask
# =====================================================

trigger:
- main

pool:
  name: 'AgenteLocal'  # üë∑‚Äç‚ôÇÔ∏è Aseg√∫rate que exista este agente local (Windows)

variables:
  ArtifactName: 'sgt-deploy-package'
  DeploymentPath: '$(Build.ArtifactStagingDirectory)/$(ArtifactName)'
  ServiceConnectionName: 'AZ-Conexion-SGT' # üîë Nombre de la conexi√≥n de servicio en Azure DevOps
  AppServiceName: 'sgt-app-integrated-2025'  # ‚úÖ Nombre de tu Azure App Service
  PythonVersion: '3.11' # Versi√≥n de Python a usar

# =====================================================
# 1Ô∏è‚É£ Etapa: CI - Integraci√≥n Continua (Pruebas Unitarias)
# =====================================================
stages:
- stage: CI_BuildAndTest
  displayName: 'Etapa 1: Integraci√≥n Continua (Pruebas y Empaquetado)'
  jobs:
  - job: PythonCI
    displayName: 'Job: Instalaci√≥n, Pruebas y Empaquetado'
    pool:
      name: 'AgenteLocal'
    steps:

    - task: UsePythonVersion@0
      displayName: 'Configurar Python $(PythonVersion)'
      inputs:
        versionSpec: '$(PythonVersion)'

    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest requests
      displayName: 'Instalar dependencias del proyecto'

    # ‚úÖ CORRECCI√ìN CLAVE para el error "ModuleNotFoundError: No module named 'sgt'"
    - powershell: |
        Write-Host "Ejecutando pruebas unitarias..."
        
        # 1. CD a la ra√≠z del repositorio para que pytest encuentre la carpeta 'test'
        cd "$(Build.SourcesDirectory)"
        
        # 2. A√±adir la ra√≠z del repositorio (el punto '.') al PYTHONPATH. 
        #    Esto permite que la importaci√≥n 'from sgt.usuarios_model import...' funcione.
        $env:PYTHONPATH = ".:$env:PYTHONPATH"
        Write-Host "PYTHONPATH establecido en: $env:PYTHONPATH"

        # 3. Ejecutar pytest
        # El comando 'pytest test' busca el m√≥dulo 'sgt' usando el nuevo PYTHONPATH
        pytest test --maxfail=1 --disable-warnings -v --junitxml=results.xml
      displayName: 'Ejecutar Pruebas Unitarias (FAIL ON ERROR)'
      
    - task: PublishTestResults@2
      displayName: 'Publicar Resultados de Pruebas Unitarias'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/results.xml' # Busca results.xml en cualquier subdirectorio
        failTaskOnFailedTests: true

    - task: CopyFiles@2
      displayName: 'Copiar C√≥digo de Aplicaci√≥n para Despliegue'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)'
        # ‚ö†Ô∏è Solo copiamos archivos esenciales para la ejecuci√≥n (sgt, main.py, requisitos)
        Contents: |
          sgt/**
          requirements.txt
          app.py 
          main.py # Asumiendo que tu archivo principal est√° aqu√≠
        TargetFolder: '$(DeploymentPath)'

    - task: PublishBuildArtifacts@1
      displayName: 'Publicar Artefacto de Despliegue'
      inputs:
        pathToPublish: '$(DeploymentPath)'
        artifactName: '$(ArtifactName)'

# =====================================================
# 2Ô∏è‚É£ Etapa: CD - Despliegue Continuo en Azure
# =====================================================
- stage: CD_Deployment
  displayName: 'Etapa 2: Despliegue en Azure App Service'
  dependsOn: CI_BuildAndTest
  condition: succeeded()

  jobs:
  - deployment: DeployToAzure
    displayName: 'Job: Desplegar Flask App en Azure'
    environment: 'Entorno-Integrado-SGT' # üåê Nombre de tu entorno en Azure DevOps
    pool:
      name: 'AgenteLocal' # Usamos el agente local si tiene acceso al servicio de Azure
    strategy:
      runOnce:
        deploy:
          steps:

          - task: DownloadPipelineArtifact@2
            displayName: 'Descargar Artefacto de C√≥digo Empaquetado'
            inputs:
              artifactName: '$(ArtifactName)'
              path: '$(Pipeline.Workspace)/$(ArtifactName)'

          - task: AzureWebApp@1
            displayName: 'Desplegar Flask App a Azure App Service'
            inputs:
              azureSubscription: '$(ServiceConnectionName)'
              appName: '$(AppServiceName)'
              appType: webApp
              package: '$(Pipeline.Workspace)/$(ArtifactName)/'
              # üöÄ Comando para Gunicorn: Ejecuta la aplicaci√≥n 'app' dentro del archivo 'main' que est√° en el paquete 'sgt'
              startupCommand: 'gunicorn --bind=0.0.0.0 --workers=4 --timeout=90 sgt.main:app' 

# =====================================================
# 3Ô∏è‚É£ Etapa: Test Funcional Post-Deploy
# =====================================================
- stage: Functional_Tests
  displayName: 'Etapa 3: Pruebas Funcionales Post-Despliegue'
  dependsOn: CD_Deployment
  condition: succeeded()

  jobs:
  - job: FunctionalTest
    displayName: 'Job: Validaci√≥n en Entorno Productivo (Post-Deploy)'
    pool:
      name: 'AgenteLocal'
    steps:
      - task: UsePythonVersion@0
        displayName: 'Configurar Python $(PythonVersion)'
        inputs:
          versionSpec: '$(PythonVersion)'

      - script: |
          pip install requests pytest
        displayName: 'Instalar dependencias de prueba funcional'
        
      # Descargamos el c√≥digo para acceder al test/test_sample.py
      - task: DownloadPipelineArtifact@2
        displayName: 'Descargar Artefacto para Tests Funcionales'
        inputs:
          artifactName: '$(ArtifactName)'
          path: '$(Pipeline.Workspace)/FunctionalTests' 

      - powershell: |
          Write-Host "Ejecutando pruebas funcionales en la URL desplegada..."
          # Nos movemos donde est√°n los tests (asumiendo que los tests est√°n en la ra√≠z del artefacto)
          cd "$(Pipeline.Workspace)/FunctionalTests"
          # Ejecutar los tests (necesitar√°s el m√≥dulo 'requests' y la URL de la App Service)
          pytest test/test_sample.py 
        displayName: 'Ejecutar Pruebas Funcionales Post-Despliegue'